!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Shimon Panfil: Industrial Physics and Simulations                   !!
! http://industrialphys.com                                           !!
! THE SOFTWARE IS PROVIDED "AS IS", USE IT AT YOUR OWN RISK           !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
MODULE LBEM_1SRF
USE TSURF
IMPLICIT NONE
PUBLIC

    TYPE(TSURF_TYPE)::SRF !(NS) SURFACES
    INTEGER::NU ! NUMBER OF UNKNOWNS AND CONTROL POINTS
    ! Large arrays 
    REAL(F64),ALLOCATABLE,DIMENSION(:,:)::LM !(NU,NU)
    REAL(F64),ALLOCATABLE,DIMENSION(:)::QTOT !(NU)
    REAL(F64),ALLOCATABLE,DIMENSION(:)::Q !(NU) AUXILIARY
    REAL(F64),ALLOCATABLE,DIMENSION(:)::CHRG !(NU) CHARGES
    REAL(F32),ALLOCATABLE,DIMENSION(:,:)::CP !(3,NU)
    REAL(F64),ALLOCATABLE,DIMENSION(:)::XPOT !(NU)
    REAL(F64)::PHI_NRM
    REAL(F32)::MAG_R,MAG_H,MAG_POS(3),MAG_DIR(3) !MAGNET PARAMETERS
    REAL(F64)::MAG_MZ
    REAL(F64),PARAMETER::MAG_NORM=ONEOVER4PI_F64*10**4


CONTAINS
! CALLED WHEN SRF INITIALIZED
SUBROUTINE INIT_LBEM(FLAG)
    INTEGER::FLAG,I
    NU=SRF%NT
    ALLOCATE(LM(NU,NU),QTOT(NU),XPOT(NU),CP(3,NU),Q(NU),CHRG(NU),STAT=FLAG)
    IF(FLAG/=0) RETURN
    CALL LBEM_MK_QTOT1(SRF)
    CALL LBEM_MK_CNTR1(SRF)
    CALL LBEM_MK_MAT1(SRF)
    Q=ONE_F64
    CALL GAUSS_JORDAN(LM,NU,Q,1)
    PHI_NRM=ZERO_F64
    DO I=1,NU
    PHI_NRM=PHI_NRM+QTOT(I)*Q(I)
    ENDDO
ENDSUBROUTINE INIT_LBEM

SUBROUTINE CLEAN_LBEM()
    CALL CLEAN_TSURF(SRF)
    IF(ALLOCATED(LM)) DEALLOCATE(LM)
    IF(ALLOCATED(QTOT)) DEALLOCATE(QTOT)
    IF(ALLOCATED(XPOT)) DEALLOCATE(XPOT)
    IF(ALLOCATED(CP)) DEALLOCATE(CP)
    IF(ALLOCATED(Q)) DEALLOCATE(Q)
    IF(ALLOCATED(CHRG)) DEALLOCATE(CHRG)
ENDSUBROUTINE CLEAN_LBEM

! CONSTANT CHARGES
SUBROUTINE LBEM_MK_QTOT1(S)
    TYPE(TSURF_TYPE):: S
    INTEGER::I,V1,V2,V3
    REAL(F32)::A,B(3),C(3),W(3)
    DO I=1,S%NT 
        V1=S%TVEC(1,I)
        V2=S%TVEC(2,I)
        V3=S%TVEC(3,I)
        B=S%VVEC(:,V2)-S%VVEC(:,V1)
        C=S%VVEC(:,V3)-S%VVEC(:,V1)
        W=CROSS_F32(B,C)
        A=HALF_F32*SQRT(DOT_F32(W,W))
        QTOT(I)=A
    ENDDO
ENDSUBROUTINE LBEM_MK_QTOT1

SUBROUTINE LBEM_MK_CNTR1(S)
    TYPE(TSURF_TYPE):: S
    INTEGER::I,V1,V2,V3
    DO I=1,S%NT 
        V1=S%TVEC(1,I)
        V2=S%TVEC(2,I)
        V3=S%TVEC(3,I)
        CP(:,I)=THIRD_F32*(S%VVEC(:,V1)+S%VVEC(:,V2)+S%VVEC(:,V3))
    ENDDO
ENDSUBROUTINE LBEM_MK_CNTR1

SUBROUTINE LBEM_MK_MAT1(S)
    TYPE(TSURF_TYPE):: S
    REAL(F64)::LPL_GF_TSURF1
    EXTERNAL  LPL_GF_TSURF1
    INTEGER::I,J
    DO I=1,NU
        DO J=1,NU                
            LM(J,I)=LPL_GF_TSURF1(S,CP(:,J),I)
        ENDDO
    ENDDO
ENDSUBROUTINE LBEM_MK_MAT1

REAL(F64) FUNCTION PSI(DST) ! EXTERNAL POTENTIAL
    REAL(F32)::DST(3)
    REAL(F64)::LPL_GF_CYL
    EXTERNAL LPL_GF_CYL
    PSI=LPL_GF_CYL(MAG_POS,MAG_DIR,MAG_R,MAG_H,DST)*MAG_MZ*MAG_NORM
ENDFUNCTION PSI

SUBROUTINE GET_XPOT(PNT)
    REAL(F32)::PNT(3,NU)
    INTEGER::I
    DO I=1,NU
        XPOT(I)=PSI(PNT(:,I))
    ENDDO
ENDSUBROUTINE GET_XPOT

SUBROUTINE GET_CHRG(PNT)
    REAL(F32)::PNT(3,NU)
    INTEGER::I,J
    CALL GET_XPOT(PNT)
    REAL(F64)::PHI,A,B
    PHI=ZERO_F64
    DO I=1,NU
        DO J=1,NU
            A=LM(I,J)*XPOT(J)
        ENDDO
        PHI=PHI+A*QTOT(I)
    ENDDO
    PHI=PHI/PHI_NRM !POTENTIAL ON SURFACE
    

ENDSUBROUTINE GET_CHRG
ENDMODULE LBEM_1SRF
