!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Shimon Panfil: Industrial Physics and Simulations                   !!
! http://industrialphys.com                                           !!
! THE SOFTWARE IS PROVIDED "AS IS", USE IT AT YOUR OWN RISK           !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!! FLOAT ARRAYS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
MODULE DATA_BUF
    USE,INTRINSIC:: ISO_C_BINDING
    IMPLICIT NONE
    PUBLIC
    INTEGER,PARAMETER::F32=KIND(1.0E0)
    INTEGER,PARAMETER::F64=KIND(1.0D0)
    INTEGER,PARAMETER::LBL_I08=0,LBL_F32=16,LBL_F64=32,LBL_C32=48,LBL_C64=64,LBL_I32=80
    INTEGER,PARAMETER::HDR_SIZE=8

!        PI,E  40 DIGITS ENOUGH EVEN FOR QUAD
    REAL(F32),PARAMETER :: PI_F32=                          &
 &           3.141592653589793238462643383279502884197 
    REAL(F64),PARAMETER :: PI_F64=                          & 
 &           3.141592653589793238462643383279502884197D0
    REAL(F32),PARAMETER :: E_F32=                            & 
 &               2.718281828459045235360287471352662497757
    REAL(F64),PARAMETER :: E_F64=                            &
 &                 2.718281828459045235360287471352662497757D0
    REAL(F32),PARAMETER :: TINY_F32=1.0E-30 
    REAL(F32),PARAMETER :: HUGE_F32=1.0E30   
    REAL(F64),PARAMETER :: TINY_F64=1.0D-300
    REAL(F64),PARAMETER :: HUGE_F64=1.0D300 
    REAL(F32),PARAMETER :: SMALL_F32=1.0E-20 
    REAL(F32),PARAMETER :: LARGE_F32=1.0E20   
    REAL(F64),PARAMETER ::SMALL_F64=1.0D-200
    REAL(F64),PARAMETER ::LARGE_F64=1.0D200 

    REAL(F32),PARAMETER :: ZERO_F32=0.0E0
    REAL(F64),PARAMETER :: ZERO_F64=0.0D0
    REAL(F32),PARAMETER :: ONE_F32=1.0E0
    REAL(F64),PARAMETER :: ONE_F64=1.0D0
    REAL(F32),PARAMETER :: TWO_F32=2.0E0
    REAL(F64),PARAMETER :: TWO_F64=2.0D0
    REAL(F32),PARAMETER :: HALF_F32=0.5E0
    REAL(F64),PARAMETER :: HALF_F64=0.5D0
    REAL(F32),PARAMETER :: THIRD_F32=1.0E0/3.0E0
    REAL(F64),PARAMETER :: THIRD_F64=1.0D0/3.0D0
    REAL(F32),PARAMETER :: QUART_F32=0.25E0
    REAL(F64),PARAMETER :: QUART_F64=0.25D0

    COMPLEX(F32),PARAMETER::I_F32=CMPLX(0.0,1.0,F32)
    COMPLEX(F64),PARAMETER::I_F64=CMPLX(0.0,1.0,F64)

    REAL(F32),PARAMETER::ONEOVER4PI_F32=QUART_F32/PI_F32
    REAL(F64),PARAMETER::ONEOVER4PI_F64=QUART_F64/PI_F64
    REAL(F32),PARAMETER::TORAD_F32=PI_F32/180.0_F32
    REAL(F64),PARAMETER::TORAD_F64=PI_F64/180.0_F64

    TYPE :: CDATA_F32 
        REAL(F32),ALLOCATABLE,DIMENSION(:)::BUF  
        INTEGER::HDR(HDR_SIZE)
    END TYPE  CDATA_F32 

    TYPE :: CDATA_F64 
        REAL(F64),ALLOCATABLE,DIMENSION(:)::BUF  
        INTEGER::HDR(HDR_SIZE)
    END TYPE  CDATA_F64 
  
CONTAINS
! FLOAT

REAL(F32) FUNCTION LENGTH_F32(A) 
    REAL(F32)::A(3)
    LENGTH_F32=SQRT(A(1)**2+A(2)**2+A(3)**2)
ENDFUNCTION LENGTH_F32

REAL(F32) FUNCTION DOT_F32(A,B) 
    REAL(F32)::A(3),B(3)
    DOT_F32=A(1)*B(1)+A(2)*B(2)+A(3)*B(3)
ENDFUNCTION DOT_F32

COMPLEX(F32) FUNCTION CDOT_F32(A,B)
    COMPLEX(F32)::A(3)
    REAL(F32)::B(3)
    CDOT_F32=A(1)*B(1)+A(2)*B(2)+A(3)*B(3)
ENDFUNCTION CDOT_F32

FUNCTION CROSS_F32(A,B) RESULT(C)
    REAL(F32)::A(3),B(3),C(3)
    C(1)=A(2)*B(3)-A(3)*B(2)
    C(2)=A(3)*B(1)-A(1)*B(3)
    C(3)=A(1)*B(2)-A(2)*B(1)
ENDFUNCTION CROSS_F32

FUNCTION CCROSS_F32(A,B) RESULT(C)
    COMPLEX(F32)::A(3),C(3)
    REAL(F32)::B(3)
    C(1)=A(2)*B(3)-A(3)*B(2)
    C(2)=A(3)*B(1)-A(1)*B(3)
    C(3)=A(1)*B(2)-A(2)*B(1)
ENDFUNCTION CCROSS_F32

FUNCTION MXV_F32(A,B) RESULT(C)
    REAL(F32)::A(3,3),C(3),B(3)
        C(1)=A(1,1)*B(1)+A(1,2)*B(2)+A(1,3)*B(3)
        C(2)=A(2,1)*B(1)+A(2,2)*B(2)+A(2,3)*B(3)
        C(3)=A(3,1)*B(1)+A(3,2)*B(2)+A(3,3)*B(3)
ENDFUNCTION MXV_F32

FUNCTION CMXV_F32(A,B) RESULT(C)
    COMPLEX(F32)::A(3,3),C(3)
    REAL(F32)::B(3)    
        C(1)=A(1,1)*B(1)+A(1,2)*B(2)+A(1,3)*B(3)
        C(2)=A(2,1)*B(1)+A(2,2)*B(2)+A(2,3)*B(3)
        C(3)=A(3,1)*B(1)+A(3,2)*B(2)+A(3,3)*B(3)
ENDFUNCTION CMXV_F32

!making rotation matrix RxRyRz
FUNCTION ROT_MAT_F32 (AX,AY,AZ) RESULT(M)
    REAL(F32)::AX,AY,AZ,M(3,3)
    REAL(F32)::CZ,SZ,CY,SY,CX,SX
    CX=COS(AX*TORAD_F32);SX=SIN(AX*TORAD_F32)
    CY=COS(AY*TORAD_F32);SY=SIN(AY*TORAD_F32)
    CZ=COS(AZ*TORAD_F32);SZ=SIN(AZ*TORAD_F32)
    M(1,1)=CY*CZ;          M(1,2)=-CY*SZ;         M(1,3)=SY
    M(2,1)=SX*SY*CZ+CX*SZ; M(2,2)=-SX*SY*SZ+CX*CZ;M(2,3)=-SX*CY
    M(3,1)=-CX*SY*CZ+SX*SZ;M(3,2)=CX*SY*SZ+SX*CZ; M(3,3)=CX*CY
ENDFUNCTION ROT_MAT_F32


FUNCTION TRG_AREA_F32(TRG) RESULT (RES)
    REAL(F32)::TRG(3,3),RES
    REAL(F32):: W(3),U(3),V(3)
    U=TRG(:,2)-TRG(:,1)
    V=TRG(:,3)-TRG(:,1)
    W=CROSS_F32(U,V)
    RES=HALF_F32*LENGTH_F32(W)
ENDFUNCTION  TRG_AREA_F32

! DOUBLE

REAL(F64) FUNCTION LENGTH_F64(A) 
    REAL(F64)::A(3)
    LENGTH_F64=SQRT(A(1)**2+A(2)**2+A(3)**2)
ENDFUNCTION LENGTH_F64

REAL(F64) FUNCTION DOT_F64(A,B) 
    REAL(F64)::A(3),B(3)
    DOT_F64=A(1)*B(1)+A(2)*B(2)+A(3)*B(3)
ENDFUNCTION DOT_F64

COMPLEX(F64) FUNCTION CDOT_F64(A,B)
    COMPLEX(F64)::A(3)
    REAL(F64)::B(3)
    CDOT_F64=A(1)*B(1)+A(2)*B(2)+A(3)*B(3)
ENDFUNCTION CDOT_F64

FUNCTION CROSS_F64(A,B) RESULT(C)
    REAL(F64)::A(3),B(3),C(3)
    C(1)=A(2)*B(3)-A(3)*B(2)
    C(2)=A(3)*B(1)-A(1)*B(3)
    C(3)=A(1)*B(2)-A(2)*B(1)
ENDFUNCTION CROSS_F64

FUNCTION CCROSS_F64(A,B) RESULT(C)
    COMPLEX(F64)::A(3),C(3)
    REAL(F64)::B(3)
    C(1)=A(2)*B(3)-A(3)*B(2)
    C(2)=A(3)*B(1)-A(1)*B(3)
    C(3)=A(1)*B(2)-A(2)*B(1)
ENDFUNCTION CCROSS_F64

FUNCTION MXV_F64(A,B) RESULT(C)
    REAL(F64)::A(3,3),C(3),B(3)
        C(1)=A(1,1)*B(1)+A(1,2)*B(2)+A(1,3)*B(3)
        C(2)=A(2,1)*B(1)+A(2,2)*B(2)+A(2,3)*B(3)
        C(3)=A(3,1)*B(1)+A(3,2)*B(2)+A(3,3)*B(3)
ENDFUNCTION MXV_F64

FUNCTION CMXV_F64(A,B) RESULT(C)
    COMPLEX(F64)::A(3,3),C(3)
    REAL(F64)::B(3)    
        C(1)=A(1,1)*B(1)+A(1,2)*B(2)+A(1,3)*B(3)
        C(2)=A(2,1)*B(1)+A(2,2)*B(2)+A(2,3)*B(3)
        C(3)=A(3,1)*B(1)+A(3,2)*B(2)+A(3,3)*B(3)
ENDFUNCTION CMXV_F64

!making rotation matrix RxRyRz
FUNCTION ROT_MAT_F64 (AX,AY,AZ) RESULT(M)
    REAL(F64)::AX,AY,AZ,M(3,3)
    REAL(F64)::CZ,SZ,CY,SY,CX,SX
    CX=COS(AX*TORAD_F64);SX=SIN(AX*TORAD_F64)
    CY=COS(AY*TORAD_F64);SY=SIN(AY*TORAD_F64)
    CZ=COS(AZ*TORAD_F64);SZ=SIN(AZ*TORAD_F64)
    M(1,1)=CY*CZ;          M(1,2)=-CY*SZ;         M(1,3)=SY
    M(2,1)=SX*SY*CZ+CX*SZ; M(2,2)=-SX*SY*SZ+CX*CZ;M(2,3)=-SX*CY
    M(3,1)=-CX*SY*CZ+SX*SZ;M(3,2)=CX*SY*SZ+SX*CZ; M(3,3)=CX*CY
ENDFUNCTION ROT_MAT_F64

    
LOGICAL FUNCTION CMP_HDR(H1,H2)
    INTEGER::H1(HDR_SIZE),H2(HDR_SIZE)
    CMP_HDR=SUM(ABS(H1-H2))==0
ENDFUNCTION CMP_HDR

SUBROUTINE READ_HDR(FNAME,FLAG,H)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG,H(HDR_SIZE)
    INTEGER::RDUNITB
    OPEN(NEWUNIT=RDUNITB,FILE=FNAME,ACCESS="STREAM",&
        STATUS="OLD",IOSTAT=FLAG)
    IF(FLAG/=0) RETURN
    READ(RDUNITB) H
    CLOSE(RDUNITB)
    FLAG=0
ENDSUBROUTINE READ_HDR


! float data    
SUBROUTINE MK_HDR_1_F32(H,N1)
    INTEGER::H(HDR_SIZE),N1
    H=1
    H(1)=LBL_F32+1
    H(2)=N1
ENDSUBROUTINE MK_HDR_1_F32
SUBROUTINE MK_HDR_2_F32(H,N1,N2)
    INTEGER::H(HDR_SIZE),N1,N2
    H=1
    H(1)=LBL_F32+2
    H(2)=N1
    H(3)=N2
ENDSUBROUTINE MK_HDR_2_F32
SUBROUTINE MK_HDR_3_F32(H,N1,N2,N3)
    INTEGER::H(HDR_SIZE),N1,N2,N3
    H=1
    H(1)=LBL_F32+3
    H(2)=N1
    H(3)=N2
    H(4)=N3
ENDSUBROUTINE MK_HDR_3_F32
SUBROUTINE MK_HDR_4_F32(H,N1,N2,N3,N4)
    INTEGER::H(HDR_SIZE),N1,N2,N3,N4
    H=1
    H(1)=LBL_F32+4
    H(2)=N1
    H(3)=N2
    H(4)=N3
    H(5)=N4
ENDSUBROUTINE MK_HDR_4_F32
SUBROUTINE MK_HDR_5_F32(H,N1,N2,N3,N4,N5)
    INTEGER::H(HDR_SIZE),N1,N2,N3,N4,N5
    H=1
    H(1)=LBL_F32+5
    H(2)=N1
    H(3)=N2
    H(4)=N3
    H(5)=N4
    H(6)=N5
ENDSUBROUTINE MK_HDR_5_F32
SUBROUTINE MK_HDR_6_F32(H,N1,N2,N3,N4,N5,N6)
    INTEGER::H(HDR_SIZE),N1,N2,N3,N4,N5,N6
    H=1
    H(1)=LBL_F32+6
    H(2)=N1
    H(3)=N2
    H(4)=N3
    H(5)=N4
    H(6)=N5
    H(7)=N6
ENDSUBROUTINE MK_HDR_6_F32
SUBROUTINE MK_HDR_7_F32(H,N1,N2,N3,N4,N5,N6,N7)
    INTEGER::H(HDR_SIZE),N1,N2,N3,N4,N5,N6,N7
    H=1
    H(1)=LBL_F32+7
    H(2)=N1
    H(3)=N2
    H(4)=N3
    H(5)=N4
    H(6)=N5
    H(7)=N6
    H(8)=N7
ENDSUBROUTINE MK_HDR_7_F32


SUBROUTINE READ_ARR_7_F32(FNAME,FLAG,A,N1,N2,N3,N4,N5,N6,N7)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1,N2,N3,N4,N5,N6,N7)
    INTEGER::N1,N2,N3,N4,N5,N6,N7
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_7_F32(H1,N1,N2,N3,N4,N5,N6,N7)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_7_F32

SUBROUTINE WRITE_ARR_7_F32(FNAME,FLAG,A,N1,N2,N3,N4,N5,N6,N7)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1,N2,N3,N4,N5,N6,N7)
    INTEGER::N1,N2,N3,N4,N5,N6,N7
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_7_F32(H1,N1,N2,N3,N4,N5,N6,N7)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_7_F32

SUBROUTINE READ_ARR_6_F32(FNAME,FLAG,A,N1,N2,N3,N4,N5,N6)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1,N2,N3,N4,N5,N6)
    INTEGER::N1,N2,N3,N4,N5,N6
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_6_F32(H1,N1,N2,N3,N4,N5,N6)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_6_F32

SUBROUTINE WRITE_ARR_6_F32(FNAME,FLAG,A,N1,N2,N3,N4,N5,N6)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1,N2,N3,N4,N5,N6)
    INTEGER::N1,N2,N3,N4,N5,N6
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_6_F32(H1,N1,N2,N3,N4,N5,N6)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_6_F32

SUBROUTINE READ_ARR_5_F32(FNAME,FLAG,A,N1,N2,N3,N4,N5)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1,N2,N3,N4,N5)
    INTEGER::N1,N2,N3,N4,N5
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_5_F32(H1,N1,N2,N3,N4,N5)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_5_F32

SUBROUTINE WRITE_ARR_5_F32(FNAME,FLAG,A,N1,N2,N3,N4,N5)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1,N2,N3,N4,N5)
    INTEGER::N1,N2,N3,N4,N5
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_5_F32(H1,N1,N2,N3,N4,N5)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_5_F32

SUBROUTINE READ_ARR_4_F32(FNAME,FLAG,A,N1,N2,N3,N4)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1,N2,N3,N4)
    INTEGER::N1,N2,N3,N4
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_4_F32(H1,N1,N2,N3,N4)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_4_F32

SUBROUTINE WRITE_ARR_4_F32(FNAME,FLAG,A,N1,N2,N3,N4)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1,N2,N3,N4)
    INTEGER::N1,N2,N3,N4
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_4_F32(H1,N1,N2,N3,N4)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_4_F32

SUBROUTINE READ_ARR_3_F32(FNAME,FLAG,A,N1,N2,N3)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1,N2,N3)
    INTEGER::N1,N2,N3
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_3_F32(H1,N1,N2,N3)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_3_F32

SUBROUTINE WRITE_ARR_3_F32(FNAME,FLAG,A,N1,N2,N3)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1,N2,N3)
    INTEGER::N1,N2,N3
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_3_F32(H1,N1,N2,N3)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_3_F32

SUBROUTINE READ_ARR_2_F32(FNAME,FLAG,A,N1,N2)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1,N2)
    INTEGER::N1,N2
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_2_F32(H1,N1,N2)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_2_F32

SUBROUTINE WRITE_ARR_2_F32(FNAME,FLAG,A,N1,N2)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1,N2)
    INTEGER::N1,N2
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_2_F32(H1,N1,N2)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_2_F32

SUBROUTINE READ_ARR_1_F32(FNAME,FLAG,A,N1)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1)
    INTEGER::N1
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_1_F32(H1,N1)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_1_F32

SUBROUTINE WRITE_ARR_1_F32(FNAME,FLAG,A,N1)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F32)::A(N1)
    INTEGER::N1
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_1_F32(H1,N1)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_1_F32
SUBROUTINE CLEAN_CDATA_F32(D)
    TYPE(CDATA_F32),INTENT(INOUT) :: D
    IF(ALLOCATED(D%BUF)) DEALLOCATE(D%BUF)
    D%HDR=0
END SUBROUTINE CLEAN_CDATA_F32

SUBROUTINE WRITE_CDATA_F32(D,FNAME,FLAG)
    TYPE(CDATA_F32),INTENT(INOUT):: D
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    INTEGER::WRUNITB
    OPEN(NEWUNIT=WRUNITB,FILE=FNAME,ACCESS="STREAM",&
        STATUS="REPLACE",IOSTAT=FLAG)
    IF(FLAG>0) RETURN
    WRITE(WRUNITB,IOSTAT=FLAG) D%HDR,D%BUF
    CLOSE(WRUNITB)
END SUBROUTINE WRITE_CDATA_F32

SUBROUTINE READ_CDATA_F32(D,FNAME,FLAG)
    TYPE(CDATA_F32),INTENT(INOUT):: D    
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    INTEGER::RDUNITB,N,I
    OPEN(NEWUNIT=RDUNITB,FILE=FNAME,ACCESS="STREAM",&
        STATUS="OLD",IOSTAT=FLAG)
    IF(FLAG/=0) RETURN
    CALL CLEAN_CDATA_F32(D)
    READ(RDUNITB) D%HDR
    N=1 ! COMPUTE TOTAL SIZE
    DO I=2,HDR_SIZE
        N=N*D%HDR(I);
    ENDDO
    ALLOCATE(D%BUF(N),STAT=FLAG)
    IF(FLAG/=0) RETURN
    READ(RDUNITB,IOSTAT=FLAG) D%BUF
    CLOSE(RDUNITB)    
    
END SUBROUTINE READ_CDATA_F32
        
! double data

SUBROUTINE MK_HDR_1_F64(H,N1)
    INTEGER::H(HDR_SIZE),N1
    H=1
    H(1)=LBL_F64+1
    H(2)=N1
ENDSUBROUTINE MK_HDR_1_F64
SUBROUTINE MK_HDR_2_F64(H,N1,N2)
    INTEGER::H(HDR_SIZE),N1,N2
    H=1
    H(1)=LBL_F64+2
    H(2)=N1
    H(3)=N2
ENDSUBROUTINE MK_HDR_2_F64
SUBROUTINE MK_HDR_3_F64(H,N1,N2,N3)
    INTEGER::H(HDR_SIZE),N1,N2,N3
    H=1
    H(1)=LBL_F64+3
    H(2)=N1
    H(3)=N2
    H(4)=N3
ENDSUBROUTINE MK_HDR_3_F64
SUBROUTINE MK_HDR_4_F64(H,N1,N2,N3,N4)
    INTEGER::H(HDR_SIZE),N1,N2,N3,N4
    H=1
    H(1)=LBL_F64+4
    H(2)=N1
    H(3)=N2
    H(4)=N3
    H(5)=N4
ENDSUBROUTINE MK_HDR_4_F64
SUBROUTINE MK_HDR_5_F64(H,N1,N2,N3,N4,N5)
    INTEGER::H(HDR_SIZE),N1,N2,N3,N4,N5
    H=1
    H(1)=LBL_F64+5
    H(2)=N1
    H(3)=N2
    H(4)=N3
    H(5)=N4
    H(6)=N5
ENDSUBROUTINE MK_HDR_5_F64
SUBROUTINE MK_HDR_6_F64(H,N1,N2,N3,N4,N5,N6)
    INTEGER::H(HDR_SIZE),N1,N2,N3,N4,N5,N6
    H=1
    H(1)=LBL_F64+6
    H(2)=N1
    H(3)=N2
    H(4)=N3
    H(5)=N4
    H(6)=N5
    H(7)=N6
ENDSUBROUTINE MK_HDR_6_F64
SUBROUTINE MK_HDR_7_F64(H,N1,N2,N3,N4,N5,N6,N7)
    INTEGER::H(HDR_SIZE),N1,N2,N3,N4,N5,N6,N7
    H=1
    H(1)=LBL_F64+7
    H(2)=N1
    H(3)=N2
    H(4)=N3
    H(5)=N4
    H(6)=N5
    H(7)=N6
    H(8)=N7
ENDSUBROUTINE MK_HDR_7_F64


SUBROUTINE READ_ARR_7_F64(FNAME,FLAG,A,N1,N2,N3,N4,N5,N6,N7)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1,N2,N3,N4,N5,N6,N7)
    INTEGER::N1,N2,N3,N4,N5,N6,N7
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_7_F64(H1,N1,N2,N3,N4,N5,N6,N7)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_7_F64

SUBROUTINE WRITE_ARR_7_F64(FNAME,FLAG,A,N1,N2,N3,N4,N5,N6,N7)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1,N2,N3,N4,N5,N6,N7)
    INTEGER::N1,N2,N3,N4,N5,N6,N7
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_7_F64(H1,N1,N2,N3,N4,N5,N6,N7)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_7_F64

SUBROUTINE READ_ARR_6_F64(FNAME,FLAG,A,N1,N2,N3,N4,N5,N6)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1,N2,N3,N4,N5,N6)
    INTEGER::N1,N2,N3,N4,N5,N6
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_6_F64(H1,N1,N2,N3,N4,N5,N6)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_6_F64

SUBROUTINE WRITE_ARR_6_F64(FNAME,FLAG,A,N1,N2,N3,N4,N5,N6)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1,N2,N3,N4,N5,N6)
    INTEGER::N1,N2,N3,N4,N5,N6
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_6_F64(H1,N1,N2,N3,N4,N5,N6)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_6_F64
SUBROUTINE READ_ARR_5_F64(FNAME,FLAG,A,N1,N2,N3,N4,N5)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1,N2,N3,N4,N5)
    INTEGER::N1,N2,N3,N4,N5
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_5_F64(H1,N1,N2,N3,N4,N5)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_5_F64

SUBROUTINE WRITE_ARR_5_F64(FNAME,FLAG,A,N1,N2,N3,N4,N5)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1,N2,N3,N4,N5)
    INTEGER::N1,N2,N3,N4,N5
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_5_F64(H1,N1,N2,N3,N4,N5)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_5_F64

SUBROUTINE READ_ARR_4_F64(FNAME,FLAG,A,N1,N2,N3,N4)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1,N2,N3,N4)
    INTEGER::N1,N2,N3,N4
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_4_F64(H1,N1,N2,N3,N4)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_4_F64

SUBROUTINE WRITE_ARR_4_F64(FNAME,FLAG,A,N1,N2,N3,N4)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1,N2,N3,N4)
    INTEGER::N1,N2,N3,N4
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_4_F64(H1,N1,N2,N3,N4)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_4_F64

SUBROUTINE READ_ARR_3_F64(FNAME,FLAG,A,N1,N2,N3)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1,N2,N3)
    INTEGER::N1,N2,N3
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_3_F64(H1,N1,N2,N3)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_3_F64

SUBROUTINE WRITE_ARR_3_F64(FNAME,FLAG,A,N1,N2,N3)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1,N2,N3)
    INTEGER::N1,N2,N3
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_3_F64(H1,N1,N2,N3)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_3_F64

SUBROUTINE READ_ARR_2_F64(FNAME,FLAG,A,N1,N2)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1,N2)
    INTEGER::N1,N2
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_2_F64(H1,N1,N2)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_2_F64

SUBROUTINE WRITE_ARR_2_F64(FNAME,FLAG,A,N1,N2)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1,N2)
    INTEGER::N1,N2
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_2_F64(H1,N1,N2)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_2_F64

SUBROUTINE READ_ARR_1_F64(FNAME,FLAG,A,N1)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1)
    INTEGER::N1
    INTEGER::UNITB,H1(HDR_SIZE),H2(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="OLD")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_1_F64(H1,N1)

    READ(UNITB,IOSTAT=FLAG) H2
    IF(FLAG/=0) THEN
        CLOSE(UNITB)
        RETURN
    ENDIF
    IF(CMP_HDR(H1,H2)) THEN
        READ(UNITB,IOSTAT=FLAG) A
        CLOSE(UNITB)
        RETURN
    ELSE
        FLAG=-1
        CLOSE(UNITB)
        RETURN
    ENDIF
ENDSUBROUTINE READ_ARR_1_F64

SUBROUTINE WRITE_ARR_1_F64(FNAME,FLAG,A,N1)
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    REAL(F64)::A(N1)
    INTEGER::N1
    INTEGER::UNITB,H1(HDR_SIZE)
    OPEN(NEWUNIT=UNITB,FILE=FNAME,ACCESS="STREAM",IOSTAT=FLAG,STATUS="REPLACE")
    IF(FLAG/=0) RETURN
    CALL MK_HDR_1_F64(H1,N1)
    WRITE(UNITB,IOSTAT=FLAG) H1,A
    CLOSE(UNITB)
ENDSUBROUTINE WRITE_ARR_1_F64
SUBROUTINE CLEAN_CDATA_F64(D)
    TYPE(CDATA_F64),INTENT(INOUT) :: D
    IF(ALLOCATED(D%BUF)) DEALLOCATE(D%BUF)
    D%HDR=0
END SUBROUTINE CLEAN_CDATA_F64

SUBROUTINE WRITE_CDATA_F64(D,FNAME,FLAG)
    TYPE(CDATA_F64),INTENT(INOUT):: D
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    INTEGER::WRUNITB
    OPEN(NEWUNIT=WRUNITB,FILE=FNAME,ACCESS="STREAM",&
        STATUS="REPLACE",IOSTAT=FLAG)
    IF(FLAG>0) RETURN
    WRITE(WRUNITB,IOSTAT=FLAG) D%HDR,D%BUF
    CLOSE(WRUNITB)
END SUBROUTINE WRITE_CDATA_F64

SUBROUTINE READ_CDATA_F64(D,FNAME,FLAG)
    TYPE(CDATA_F64),INTENT(INOUT):: D    
    CHARACTER(*) :: FNAME
    INTEGER :: FLAG
    INTEGER::RDUNITB,N,I
    OPEN(NEWUNIT=RDUNITB,FILE=FNAME,ACCESS="STREAM",&
        STATUS="OLD",IOSTAT=FLAG)
    IF(FLAG/=0) RETURN
    CALL CLEAN_CDATA_F64(D)
    READ(RDUNITB) D%HDR
    N=1 ! COMPUTE TOTAL SIZE
    DO I=2,HDR_SIZE
        N=N*D%HDR(I);
    ENDDO
    ALLOCATE(D%BUF(N),STAT=FLAG)
    IF(FLAG/=0) RETURN
    READ(RDUNITB,IOSTAT=FLAG) D%BUF
    CLOSE(RDUNITB)    
    
END SUBROUTINE READ_CDATA_F64

ENDMODULE DATA_BUF
